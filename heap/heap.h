/**************************************************************************
* @ file    :   heap.h
* @ author  :   yang yang
* @ version :   0.9
* @ date    :   2017.07.05
* @ brief   :   二叉堆的实现，可用于优先级对列. 该实现将最大值放在堆顶。如果
*               需要将最小值放在堆顶，可以通过使用相反的comparer函数来实现
* @Copyright (c)2016  chuangmi inc.
***************************************************************************/

#ifndef __HEAP_H__
#define __HEAP_H__

#include "defs.h"

typedef struct _heap_t* heap_t;

//----------------------------------------------------------------------------
// 创建heap.
//
// @initSize:   heap初始分配的空间
// @maxSize:    heap的最大的空间
// @return:     创建的heap
//----------------------------------------------------------------------------
heap_t heap_create(element_comparer comparer, int initSize, int maxSize);

//----------------------------------------------------------------------------
// 释放heap
// 用户在释放前，需保证堆内元素已释放
//----------------------------------------------------------------------------
void heap_release(heap_t heap);


//----------------------------------------------------------------------------
// 向堆 heap 中插入一个结点 - O(lgn)
// @heap
// @data
// @return  0 成功，其他错误编码
//----------------------------------------------------------------------------
int heap_insert(heap_t heap, void *data);

//----------------------------------------------------------------------------
// 从堆heap取出堆顶部的结点 - O(lg n)
// @heap 堆
// @return 成功返回栈顶元素，失败返回NULL
//----------------------------------------------------------------------------
void* heap_pop(heap_t heap);

//----------------------------------------------------------------------------
// 查看堆顶元素
// @heap 堆
//----------------------------------------------------------------------------
void* heap_peek(heap_t heap);


//----------------------------------------------------------------------------
// 获取堆的大小
// @return 大于等于0, 堆的大小。小于0: 错误编码
//----------------------------------------------------------------------------
int get_heap_size(heap_t heap);

//----------------------------------------------------------------------------
// 读取堆的当前分配的空间大小
// @return 大于等于0, 堆的已分配空间。小于0: 错误编码
//----------------------------------------------------------------------------
int get_heap_capacity(heap_t heap);

//----------------------------------------------------------------------------
// 读取堆的最大可用空间大小
// @return 大于等于0, 堆的最大分配空间。小于0: 错误编码
//----------------------------------------------------------------------------
int  get_heap_max_capacity(heap_t heap);

//----------------------------------------------------------------------------
// 查找指定的array
// comparer: 指向比较函数的指针
// startIdx: 查找的起始位置
// 返回值: 返回检索到的元素下标, 小于0则没有查到
//----------------------------------------------------------------------------
int heap_search(heap_t heap, int startIdx, element_matcher matcher, void *searchData);

//----------------------------------------------------------------------------
// 删除堆中指定下标的元素, 并返回对应的值. 删除元素后，会重新堆化保持堆特性
// @return: 返回被删除的值，如果指定index无效, 则返回NULL
//----------------------------------------------------------------------------
void *heap_remove(heap_t heap, int index);

///**
// * Remove item
// *
// * @param[in] item The item that is to be removed
// * @return item to be removed; NULL if item does not exist */
//void *heap_remove_item(heap_t * hp, const void *item);
//
///**
// * Test membership of item
// *
// * @param[in] item The item to test
// * @return 1 if the heap contains this item; otherwise 0 */
//int heap_contains_item(const heap_t * hp, const void *item);

#endif //__HEAP_H__
